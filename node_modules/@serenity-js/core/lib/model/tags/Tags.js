"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tags = void 0;
const tiny_types_1 = require("tiny-types");
const ArbitraryTag_1 = require("./ArbitraryTag");
const BrowserTag_1 = require("./BrowserTag");
const CapabilityTag_1 = require("./CapabilityTag");
const ExecutionRetriedTag_1 = require("./ExecutionRetriedTag");
const FeatureTag_1 = require("./FeatureTag");
const IssueTag_1 = require("./IssueTag");
const ManualTag_1 = require("./ManualTag");
const PlatformTag_1 = require("./PlatformTag");
const ProjectTag_1 = require("./ProjectTag");
const ThemeTag_1 = require("./ThemeTag");
function hasCustomDeserialiser(tagType) {
    return Object.prototype.hasOwnProperty.call(tagType, 'fromJSON');
}
/**
 * @package
 */
class Tags {
    static supportedTypes = new Map([
        ArbitraryTag_1.ArbitraryTag,
        BrowserTag_1.BrowserTag,
        CapabilityTag_1.CapabilityTag,
        ExecutionRetriedTag_1.ExecutionRetriedTag,
        FeatureTag_1.FeatureTag,
        IssueTag_1.IssueTag,
        ManualTag_1.ManualTag,
        PlatformTag_1.PlatformTag,
        ProjectTag_1.ProjectTag,
        ThemeTag_1.ThemeTag,
    ].map(tagType => [tagType.Type, tagType]));
    static Pattern = /^@([\w-]+)[\s:]?(.*)/i;
    static matchTags(tagText) {
        if (tagText === '') {
            return [];
        }
        const [, tagType, value] = Tags.Pattern.exec(tagText);
        return (0, tiny_types_1.match)(tagType.toLowerCase())
            .when('manual', _ => [new ManualTag_1.ManualTag()])
            .when(/^issues?$/, _ => value.split(',').map(value => new IssueTag_1.IssueTag(value.trim())))
            .else(value => [new ArbitraryTag_1.ArbitraryTag(value.trim())]);
    }
    static fromJSON(o) {
        const type = (0, tiny_types_1.ensure)('serialised tag type', o.type, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isString)());
        if (!this.supportedTypes.has(type)) {
            return new ArbitraryTag_1.ArbitraryTag(o.name);
        }
        const found = this.supportedTypes.get(type);
        if (hasCustomDeserialiser(found)) {
            return found.fromJSON(o);
        }
        return new found(o.name);
    }
    static from(text) {
        const tags = text.split(/\s+/)
            .filter(word => word.startsWith('@'))
            .flatMap(tag => Tags.matchTags(tag));
        return tags ?? Tags.matchTags(text);
    }
    static stripFrom(text) {
        return text.split(/\s+/)
            .map(word => Tags.Pattern.test(word) ? undefined : word)
            .filter(Boolean)
            .join(' ')
            .trim();
    }
}
exports.Tags = Tags;
//# sourceMappingURL=Tags.js.map