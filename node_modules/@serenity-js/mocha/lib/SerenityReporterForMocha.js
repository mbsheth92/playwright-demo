"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerenityReporterForMocha = void 0;
const events_1 = require("@serenity-js/core/lib/events");
const io_1 = require("@serenity-js/core/lib/io");
const model_1 = require("@serenity-js/core/lib/model");
const mocha_1 = require("mocha");
const mappers_1 = require("./mappers");
const OutcomeRecorder_1 = require("./OutcomeRecorder");
/**
 * @package
 */
class SerenityReporterForMocha extends mocha_1.reporters.Base {
    serenity;
    requirementsHierarchy;
    testMapper;
    outcomeMapper = new mappers_1.MochaOutcomeMapper();
    recorder = new OutcomeRecorder_1.OutcomeRecorder();
    suiteIds = [];
    currentSceneId = undefined;
    /**
     * @param {Serenity} serenity
     * @param requirementsHierarchy
     * @param {mocha~Runner} runner
     * @param {mocha~MochaOptions} options
     */
    constructor(serenity, requirementsHierarchy, runner, options) {
        super(runner, options);
        this.serenity = serenity;
        this.requirementsHierarchy = requirementsHierarchy;
        this.testMapper = new mappers_1.MochaTestMapper(this.serenity.cwd());
        runner.on(mocha_1.Runner.constants.EVENT_RUN_BEGIN, () => {
            this.emit(new events_1.TestRunStarts(this.serenity.currentTime()));
        });
        runner.on(mocha_1.Runner.constants.EVENT_SUITE_BEGIN, (suite) => {
            if (suite.root === false) {
                this.announceSuiteStartsFor(suite);
            }
        });
        runner.on(mocha_1.Runner.constants.EVENT_SUITE_END, (suite) => {
            if (suite.root === false) {
                this.announceSuiteFinishedFor(suite);
            }
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_BEGIN, (test) => {
            this.recorder.started(test);
            this.announceSceneStartsFor(test);
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_PASS, (test) => {
            this.announceRetryIfNeeded(test);
            this.recorder.finished(test.ctx ? test.ctx.currentTest : test, this.outcomeMapper.outcomeOf(test));
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_FAIL, (test, error) => {
            this.announceRetryIfNeeded(test);
            this.recorder.finished(test.ctx ? test.ctx.currentTest : test, this.outcomeMapper.outcomeOf(test, error));
        });
        runner.on(mocha_1.Runner.constants.EVENT_TEST_RETRY, (test, error) => {
            this.announceRetryIfNeeded(test);
            this.recorder.finished(!!test.ctx && test.ctx.currentTest ? test.ctx.currentTest : test, this.outcomeMapper.outcomeOf(test, error));
        });
        const announceSceneFinishedFor = SerenityReporterForMocha.prototype.announceSceneFinishedFor.bind(this);
        runner.suite.afterEach('Serenity/JS', function () {
            return announceSceneFinishedFor(this.currentTest, this.test);
        });
        // https://github.com/cypress-io/cypress/issues/7562
        runner.on('test:after:run', (test) => {
            return announceSceneFinishedFor(test, test);
        });
        // Tests without body don't trigger the above custom afterEach hook
        runner.on(mocha_1.Runner.constants.EVENT_TEST_PENDING, (test) => {
            if (!test.fn) {
                this.announceSceneSkippedFor(test);
            }
        });
    }
    done(failures, callback) {
        this.emit(new events_1.TestRunFinishes(this.serenity.currentTime()));
        this.serenity.waitForNextCue()
            .then(() => {
            this.emit(new events_1.TestRunFinished(new model_1.ExecutionSuccessful(), this.serenity.currentTime()));
            return callback(failures);
        })
            .catch(error => {
            const numberOfFailures = failures === 0
                ? 1
                : failures;
            this.emit(new events_1.TestRunFinished(new model_1.ExecutionFailedWithError(error), this.serenity.currentTime()));
            return callback(numberOfFailures);
        });
    }
    announceSuiteStartsFor(suite) {
        const suiteId = model_1.CorrelationId.create();
        this.suiteIds.push(suiteId);
        const details = new model_1.TestSuiteDetails(new model_1.Name(suite.title), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        new io_1.FileSystemLocation(io_1.Path.from(suite.file)), // all suites except for the root suite should have .file property set
        suiteId);
        this.emit(new events_1.TestSuiteStarts(details, this.serenity.currentTime()));
    }
    announceSuiteFinishedFor(suite) {
        const details = new model_1.TestSuiteDetails(new model_1.Name(suite.title), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        new io_1.FileSystemLocation(io_1.Path.from(suite.file)), // all suites except for the root suite should have .file property set
        this.suiteIds.pop());
        const outcomes = suite.tests.map(test => this.recorder.outcomeOf(test) || this.outcomeMapper.outcomeOf(test));
        const worstOutcome = outcomes.reduce((worstSoFar, outcome) => outcome.isWorseThan(worstSoFar)
            ? outcome
            : worstSoFar, new model_1.ExecutionSuccessful());
        this.emit(new events_1.TestSuiteFinished(details, worstOutcome, this.serenity.currentTime()));
    }
    announceSceneStartsFor(test) {
        this.currentSceneId = this.serenity.assignNewSceneId();
        const { scenarioDetails, scenarioTags } = this.testMapper.detailsOf(test);
        this.emit(new events_1.SceneStarts(this.currentSceneId, scenarioDetails, this.serenity.currentTime()), ...this.requirementsHierarchy.requirementTagsFor(scenarioDetails.location.path, scenarioDetails.category.value)
            .map(tag => new events_1.SceneTagged(this.currentSceneId, tag, this.serenity.currentTime())), new events_1.TestRunnerDetected(this.currentSceneId, new model_1.Name('Mocha'), this.serenity.currentTime()), ...scenarioTags.map(tag => new events_1.SceneTagged(this.currentSceneId, tag, this.serenity.currentTime())));
    }
    announceSceneFinishedFor(test, runnable) {
        const { scenarioDetails } = this.testMapper.detailsOf(test), outcome = this.recorder.outcomeOf(test) || this.outcomeMapper.outcomeOf(test);
        this.emit(new events_1.SceneFinishes(this.currentSceneId, this.serenity.currentTime()));
        return this.serenity.waitForNextCue()
            .then(() => {
            this.emit(new events_1.SceneFinished(this.currentSceneId, scenarioDetails, outcome, this.serenity.currentTime()));
            this.recorder.erase(test);
        }, error => {
            this.emit(new events_1.SceneFinished(this.currentSceneId, scenarioDetails, new model_1.ExecutionFailedWithError(error), this.serenity.currentTime()));
            this.recorder.erase(test);
            // re-throwing an error here would cause Mocha to halt test suite, which we don't want to do
            // https://github.com/mochajs/mocha/issues/1635
            runnable.error(error);
        });
    }
    announceSceneSkippedFor(test) {
        const { scenarioDetails } = this.testMapper.detailsOf(test), outcome = this.outcomeMapper.outcomeOf(test);
        this.announceSceneStartsFor(test);
        this.emit(new events_1.SceneFinishes(this.currentSceneId, this.serenity.currentTime()), new events_1.SceneFinished(this.currentSceneId, scenarioDetails, outcome, this.serenity.currentTime()));
    }
    announceRetryIfNeeded(test) {
        if (!this.isRetriable(test)) {
            return void 0;
        }
        // todo: RetryableSceneDetected(maxRetries) ?
        this.emit(new events_1.RetryableSceneDetected(this.currentSceneId, this.serenity.currentTime()), new events_1.SceneTagged(this.currentSceneId, new model_1.ArbitraryTag('retried'), // todo: replace with a dedicated tag
        this.serenity.currentTime()));
        if (this.currentRetryOf(test) > 0) {
            this.emit(new events_1.SceneTagged(this.currentSceneId, new model_1.ExecutionRetriedTag(this.currentRetryOf(test)), this.serenity.currentTime()));
        }
    }
    isRetriable(test) {
        return test.retries() >= 0;
    }
    currentRetryOf(test) {
        return test.currentRetry();
    }
    emit(...events) {
        events.forEach(event => this.serenity.announce(event));
    }
}
exports.SerenityReporterForMocha = SerenityReporterForMocha;
//# sourceMappingURL=SerenityReporterForMocha.js.map